<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Punto1-authenticator by punto1</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Punto1-authenticator</h1>
      <h2 class="project-tagline">a very secure authentication module, implementing a lot of features to prevent unauthorized access, credentials theft, data leaks and attacks</h2>
      <a href="https://github.com/punto1/punto1-authenticator" class="btn">View on GitHub</a>
      <a href="https://github.com/punto1/punto1-authenticator/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/punto1/punto1-authenticator/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="punto1-authenticator" class="anchor" href="#punto1-authenticator" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>punto1-authenticator</h1>

<p><em>a very secure authentication module, implementing many features to prevent unauthorized access, credentials theft, data leaks and attacks</em></p>

<p>If users are to trust their confident data to our systems, they should expect a huge commitment from us to keep their data safe. Authentication is an important part of a secure system. The <a href="https://auth.punto1.uno" title="demo authentication module">P U N T O 1 . U N O</a> authentication module implements many features to prevent unauthorized access, credentials theft, data leaks and attacks. Theoretically, all security is breakable. But to be efficient, breaking the security has to be too costly (in time and other resources) to be worth the effort. Our authentication module addresses man-in-the-middle attacks, replay attacks, brute-force attacks and cross-scripting attacks. </p>

<p>The punto1-authenticator is an excellent basis to kickstart a new system. If you are interested in using it for your next project, please contact me at  at punto1.uno. I am willing to open source the code after I have gained back the initial investment costs.</p>

<p>Good securty is complex too. If you are interested, read on! </p>

<h2>
<a id="monitoring-and-restricting-access" class="anchor" href="#monitoring-and-restricting-access" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Monitoring and restricting access:</h2>

<p>The account user has a lot of options in the punto1-authenticator module to restrict and monitor access (2-factor authentication, ip restrictions, email warnings). Login accounts with admin privileges can't reset their credentials, and the admin role is only enabled when the 2-factor authentication (<a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm" title="time-based one-time password algorithm">TOTP</a>) is configured, whereby an application on the user's smartphone generates every 30 seconds a unique code for the login account, which is known by the server by a secret that is shared between the server and the smartphone upon cnfiguration via a QR-code. The login is throttled at 3 attempts within 5 minutes before triggering a timeout. Accounts are easily disabled by users with the admin role, and accounts can also be given temporary access. The system can enforce a user to change his/her credentials periodically, depending on the policy that can be configured differently for every individual user. </p>

<h2>
<a id="storage" class="anchor" href="#storage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Storage:</h2>

<p>The <a href="https://password-hashing.net/">state-of-the-art memory-hard Argon2 hash function</a> is used to store the credentials in the database. Above, the credentials that are hashed by the argon2 function is not the original pass phrase that the user gave, but a sha-512 hash of a long random salt value (different for every login account) and the pass phrase. Hence, even if one would be able to crack the argon2 hash, there is another hash to find collisions for. </p>

<h2>
<a id="communication-between-browser--server" class="anchor" href="#communication-between-browser--server" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Communication between browser &amp; server:</h2>

<p>The credentials are encrypted before they are sent to the server. So even if the login page weren't protected by https <a href="https://www.ssllabs.com/ssltest/analyze.html?d=auth.punto1.uno&amp;latest" title="web server configuration audit">(correctly configured with Forward Secrecy, strong ciphers, http/2, hsts, oscp-stapling, variable DH-params etc.)</a>, the credentials sent to the server can't be intercepted. The credentials are symmetrically encrypted by AES at the browser, and the encryption/decryption key is a hash that is strengthened by the key derivation function pbkdf2. The input for the pbkdf2 hash is a concatenation of 3 strings: the unique one-time server-nonce (generated again for every page request to the login page), the unique one-time client-nonce (generated by the browser every time the login page is loaded), and the pin code or - if configured by the user - the result of the TOTP 2-factor authentication string generated by an application on your smartphone. The resulting cipher text and the client nonce are sent to the server, which has to determine the value for the decryption key first before being able to obtain the credentials, which thereafter has to be verified against the stored hash. </p>

<h2>
<a id="thwart-key-loggers" class="anchor" href="#thwart-key-loggers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Thwart key loggers:</h2>

<p>In case the user has not configured 2-factor authentication and hence uses a pincode, the surface attack is bit smaller if we can thwart most key loggers. (are we too paranoid here?)</p>

<h2>
<a id="promotes-a-high-level-of-operational-security-opsec" class="anchor" href="#promotes-a-high-level-of-operational-security-opsec" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Promotes a high level of Operational Security ("OPSEC")</h2>

<p>The weakest link in a system are humans. Choosing weak passwords, don't change passwords frequently and not restricting access can severely endanger the security of a system. The punto1-authenticator enforces policies to enforces good passwords, facilitates frequent password changes, obliges to use 2-factor authentication methods if a user wishes to obtain more privileges, logs and notifies any account activity and disables recoverability of the account credentials for accounts with privileged authorizations. All these measures contribute to operational security and to security awareness.</p>

<h2>
<a id="minimizes-the-browser-as-an-attack-vector" class="anchor" href="#minimizes-the-browser-as-an-attack-vector" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Minimizes the browser as an attack vector</h2>

<p>The browser is designed to execute untrusted code that is downloaded from the internet. As such, it is a favourite vector for  malevolents to hijack sessions, forge requests and run malicious code. 
The code in the punto1-authentication module adheres to the new "Content Security Policy (CSP)", by telling the browser via a response header that it should not permit inline style en code, and that only resources from the application's domain are allowed. This prevents most cross-scripting possibilities. Above, for all form requests a unique CSRF token is generated and verified again by the server when forms are submitted. Other measures to counter any possibilities for abuse are: </p>

<ul>
<li>The session id of cookie is a random string of 72-character length, preventing brute-force guessing.</li>
<li>The session id changes upon login and logout, prevents session fixation / replay attacks.</li>
<li>Session data is stored encrypted on server side</li>
<li>The session cookie is only set when the site is delivered over https, to prevent session hijacking.</li>
</ul>

<h2>
<a id="technology-stack" class="anchor" href="#technology-stack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Technology stack:</h2>

<p>The punto1-authenticator module is bloody fast and has a very scalable architecture. Redis is used as a session cache and as the key/value store for an asynchronous message queue, a postgres database as the main data store (with pooled connections off course), the site is optimized for http/2, and multiple uwsgi workers serve the application with nginx as a reverse proxy. 
The main components of the used technology stack:</p>

<ul>
<li>Python 3, Pyramid, SqlAlchemy, jinja2, Beaker</li>
<li>Foundation &amp; jquery</li>
<li>Postgres &amp; Redis</li>
<li>Nginx, uwsgi</li>
</ul>

<h2>
<a id="summarized" class="anchor" href="#summarized" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Summarized:</h2>

<ul>
<li>The original password never leaves the browser! A salted hash is symmetrically encrypted (with a one-time key) before it is sent to the server and stored or verified with the memory-hard argon2 algorithm.</li>
<li>The login is validated by comparing the resulting hash of a combination of a 1-time clientnonce, 1-time servernonce, pincode and password hash, to prevent replays. That resulting hash and the clientnonce are the only data that is presented to the server upon login.</li>
<li>The risk of key loggers is reduced by using a virtual keyboard for the pin code / TOTP code</li>
<li>Brute force attacks are mitigated by login throttling (no more than 3 login attempts per 5 minutes, and then a time-out for 5 minutes).</li>
<li>Password should be of at least 10 characters length, and it is enforced to consist of upper case, lower case, digits and special chars.</li>
<li>Per login account, an expiration term can be set for the credentials (password &amp; pincode), after which the user is enforced by the system to change his/her credentials.</li>
<li>When configured, a login account will only be valid only between the appointed start and end date.</li>
<li>Timing attacks are mitigated as much as possible by processing login attempts the same for valid and invalid login accounts.</li>
<li>Responses of the server don't give clues that facilitates the guessing the existence of a user account (in the password reset form for instance).</li>
<li>The user can configure to retrieve an email after each login.</li>
<li>The user can configure to retrieve an email after each unsuccessfull login attempt.</li>
<li>Every login attempt is logged.</li>
<li>Every account modification is logged.</li>
<li>Ability to configure and enfore ip restrictions on the access of a login account (both IPv4 and IPv6).
all forms are protected by <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF</a> tokens.</li>
<li>The session cookie is only set when the site is delivered over https, to prevent session hijacking.</li>
<li>Sessionid of cookie is a random string of 72-character length, preventing brute-force guessing.</li>
<li>Sessionid changes upon login and logout, prevents session fixation / replay attacks.</li>
<li>Session data is stored encrypted on server side.</li>
<li>ability to upload your public pgp key.</li>
<li>The admin role is only activated for a user when he/she has configured the time-based 2-factor authentication method (TOTP).</li>
<li>Reset functionality (forgot password, bypass ip restrictions etc) is disabled for login accounts with the admin role.</li>
<li>100% compliant with a strict Secure-Content-Policy of "default-src 'self'"</li>
<li>Bloody fast and very scalable architecture! (Redis used as a session cache and key/value store for asynchronous message queue, postgres database connections are pooled, optimized for http/2, uwsgi workers with nginx as reverse proxy for the application server)</li>
</ul>

<p>Â© DouweM, punto1.uno, may 2016</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/punto1/punto1-authenticator">Punto1-authenticator</a> is maintained by <a href="https://github.com/punto1">punto1</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
